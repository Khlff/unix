# Задача 1

## Тема: Работа с файлами - open, read, write, seek.

### Описание
Sparse file — файл, в котором последовательности нулевых байтов заменены на информацию о них. Последовательность нулевых байт внутри файла (дыры) не записывается на диск, а информация о них (смещение от начала файла в байтах и количество байт) хранится в метаданных файловой системы.

Сжатие архиваторами типа `gzip` происходит очень эффективно. Однако при распаковке все наоборот: `gzip` не заботится о создании дырок и заполняет их нулями, что может привести к значительному увеличению размера файла.

### Задача
Требуется написать программу для создания sparse-файлов.
Программа должна:
- Считать нули и заменять блоки, заполненные нулями, на `seek` для создания разреженного файла.
- Работать поблочно (по умолчанию блок 4096 байт, но должен быть параметр для задания размера блока).
- Если передан **один аргумент** (имя файла) — читать из `stdin` и записывать в указанный файл.
- Если передано **два аргумента** — читать первый файл и записывать во второй.

### Тестирование
Необходимо написать вспомогательный скрипт для тестирования, который:
1. Создаёт **тестовый файл A** размером `4*1024*1024 + 1` байт, заполненный в основном нулями.
2. Вставляет **единицы** в смещения `0`, `10000` и в конец файла.

### Действия в `runme.sh`
В файле `runme.sh` должны выполняться следующие шаги:

1. **Создать файл A**.
2. **Скопировать A в B**, сделав его разреженным:
   ```sh
   ./myprogram fileA fileB
   ```
3. **Сжать A и B с помощью gzip**.
4. **Распаковать fileB.gz в stdout и сохранить через программу в C**:
   ```sh
   gzip -cd fileB.gz | ./myprogram fileC
   ```
5. **Скопировать A в D с нестандартным размером блока (100 байт)**:
   ```sh
   ./myprogram -b 100 fileA fileD
   ```
6. **Вывести реальный размер файлов с помощью stat**:
   ```sh
   stat fileA fileA.gz fileB fileB.gz fileC fileD
   ```

### Ключевые функции
- `read()`
- `write()`
- `lseek(output, count, SEEK_CUR)`
- `ftruncate(output, size)`

